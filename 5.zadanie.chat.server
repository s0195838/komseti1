#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <mutex>
#include <winsock2.h>
#include <windows.h>
 
#pragma comment(lib, "ws2_32.lib")
#pragma warning(disable: 4996)
 
#define PORT 12345
#define MAX_CLIENTS 100
#define BUFFER_SIZE 2048
 
using namespace std;
 
mutex clients_mutex;
 
struct Client {
    SOCKET socket;
    string nickname;
    sockaddr_in addr;
};
 
vector<Client> clients;
 
// Типы сообщений
enum MessageType {
    MSG_LOGIN,
    MSG_LOGOUT,
    MSG_PUBLIC,
    MSG_PRIVATE,
    MSG_SYSTEM,
    MSG_USERLIST
};
 
struct ChatMessage {
    MessageType type;
    char from[32];
    char to[32];
    char message[BUFFER_SIZE];
};
 
// Отправка сообщения клиенту
bool SendToClient(SOCKET client_socket, const ChatMessage& msg) {
    return send(client_socket, (char*)&msg, sizeof(msg), 0) > 0;
}
 
// Отправка сообщения всем клиентам, кроме указанного
void BroadcastMessage(const ChatMessage& msg, SOCKET exclude_socket = INVALID_SOCKET) {
    lock_guard<mutex> lock(clients_mutex);
 
    for (const auto& client : clients) {
        if (client.socket != exclude_socket) {
            SendToClient(client.socket, msg);
        }
    }
}
 
// Отправка системного сообщения
void SendSystemMessage(SOCKET client_socket, const string& text) {
    ChatMessage msg;
    msg.type = MSG_SYSTEM;
    strcpy(msg.from, "SERVER");
    strcpy(msg.message, text.c_str());
    SendToClient(client_socket, msg);
}
 
// Отправка списка пользователей
void SendUserList(SOCKET client_socket) {
    lock_guard<mutex> lock(clients_mutex);
 
    string user_list = "Сейчас онлайн (" + to_string(clients.size()) + "):\n";
    for (const auto& client : clients) {
        user_list += "• " + client.nickname + "\n";
    }
 
    SendSystemMessage(client_socket, user_list);
}
 
// Поиск клиента по нику
SOCKET FindClientByNickname(const string& nickname) {
    lock_guard<mutex> lock(clients_mutex);
 
    for (const auto& client : clients) {
        if (client.nickname == nickname) {
            return client.socket;
        }
    }
    return INVALID_SOCKET;
}
 
// Проверка уникальности ника
bool IsNicknameUnique(const string& nickname) {
    lock_guard<mutex> lock(clients_mutex);
 
    for (const auto& client : clients) {
        if (client.nickname == nickname) {
            return false;
        }
    }
    return true;
}
 
// Обработчик клиента
DWORD WINAPI ClientHandler(LPVOID lpParam) {
    SOCKET client_socket = *(SOCKET*)lpParam;
    Client client_info;
    client_info.socket = client_socket;
 
    // Получение адреса клиента
    sockaddr_in client_addr;
    int addr_len = sizeof(client_addr);
    getpeername(client_socket, (sockaddr*)&client_addr, &addr_len);
    client_info.addr = client_addr;
 
    // Запрос ника
    SendSystemMessage(client_socket, "Введите ваш никнейм: ");
 
    ChatMessage login_msg;
    int bytes_received = recv(client_socket, (char*)&login_msg, sizeof(login_msg), 0);
 
    if (bytes_received <= 0) {
        closesocket(client_socket);
        return 0;
    }
 
    string nickname = login_msg.from;
 
    // Проверка ника
    if (nickname.empty() || nickname.length() > 31) {
        SendSystemMessage(client_socket, "Некорректный никнейм. Соединение закрыто.");
        closesocket(client_socket);
        return 0;
    }
 
    if (!IsNicknameUnique(nickname)) {
        SendSystemMessage(client_socket, "Этот никнейм уже занят. Соединение закрыто.");
        closesocket(client_socket);
        return 0;
    }
 
    client_info.nickname = nickname;
 
    // Добавление клиента в список
    {
        lock_guard<mutex> lock(clients_mutex);
        clients.
push_back(client_info);
    }
 
    // Приветствие
    SendSystemMessage(client_socket, "Добро пожаловать в чат, " + nickname + "!");
    SendUserList(client_socket);
 
    // Уведомление всех о новом пользователе
    ChatMessage join_msg;
    join_msg.type = MSG_SYSTEM;
    strcpy(join_msg.from, "SERVER");
    string join_text = nickname + " присоединился к чату";
    strcpy(join_msg.message, join_text.c_str());
    BroadcastMessage(join_msg, client_socket);
 
    cout << nickname << " подключился ("
        << inet_ntoa(client_addr.sin_addr) << ":"
        << ntohs(client_addr.sin_port) << ")" << endl;
    cout << "Пользователей онлайн: " << clients.size() << endl;
 
    // Основной цикл обработки сообщений
    while (true) {
        ChatMessage msg;
        bytes_received = recv(client_socket, (char*)&msg, sizeof(msg), 0);
 
        if (bytes_received <= 0) {
            break; // Клиент отключился
        }
 
        string message_text = msg.message;
 
        // Обработка команд
        if (message_text == "/exit") {
            break;
        }
        else if (message_text == "/users") {
            SendUserList(client_socket);
        }
        else if (message_text.substr(0, 8) == "/private") {
            // Формат: /private ник сообщение
            size_t space1 = message_text.find(' ', 9);
            if (space1 != string::npos) {
                string target_nick = message_text.substr(9, space1 - 9);
                string private_msg = message_text.substr(space1 + 1);
 
                SOCKET target_socket = FindClientByNickname(target_nick);
                if (target_socket != INVALID_SOCKET) {
                    // Отправка приватного сообщения
                    ChatMessage private_message;
                    private_message.type = MSG_PRIVATE;
                    strcpy(private_message.from, nickname.c_str());
                    strcpy(private_message.to, target_nick.c_str());
                    strcpy(private_message.message, private_msg.c_str());
 
                    SendToClient(target_socket, private_message);
 
                    // Подтверждение отправителю
                    SendSystemMessage(client_socket, "Приватное сообщение для " + target_nick + " отправлено");
                }
                else {
                    SendSystemMessage(client_socket, "Пользователь '" + target_nick + "' не найден");
                }
            }
            else {
                SendSystemMessage(client_socket, "Неверный формат: /private <ник> <сообщение>");
            }
        }
        else {
            // Публичное сообщение
            ChatMessage public_msg;
            public_msg.type = MSG_PUBLIC;
            strcpy(public_msg.from, nickname.c_str());
            strcpy(public_msg.message, message_text.c_str());
 
            BroadcastMessage(public_msg, client_socket);
        }
    }
 
    // Удаление клиента из списка
    {
        lock_guard<mutex> lock(clients_mutex);
        auto it = remove_if(clients.begin(), clients.end(),
            [client_socket](const Client& c) { return c.socket == client_socket; });
        clients.erase(it, clients.end());
    }
 
    // Уведомление всех об уходе пользователя
    ChatMessage leave_msg;
    leave_msg.type = MSG_SYSTEM;
    strcpy(leave_msg.from, "SERVER");
    string leave_text = nickname + " покинул чат";
    strcpy(leave_msg.message, leave_text.c_str());
    BroadcastMessage(leave_msg);
 
    cout << nickname << " отключился" << endl;
    cout << "Пользователей онлайн: " << clients.size() << endl;
 
    closesocket(client_socket);
    return 0;
}
 
int main() {
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    setlocale(LC_ALL, "Russian");
    cout << "=== СЕРВЕР ЧАТА ===\n";
    cout << "Порт: " << PORT << endl;
 
    // Инициализация Winsock
    WSADATA wsa_data;
    if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0) {
        cerr << "Ошибка инициализации Winsock" << endl;
        return 1;
    }
 
    // Создание сокета
    SOCKET server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == INVALID_SOCKET) {
        cerr << "Ошибка создания сокета" << endl;
        WSACleanup();
        return 1;
    }
 
    // Настройка адреса
    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = INADDR_ANY;
 
    // Привязка сокета
    if (bind(server_socket, (sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {
        cerr << "Ошибка привязки сокета" << endl;
        closesocket(server_socket);
        WSACleanup();
        return 1;
    }
 
    // Прослушивание
    if (listen(server_socket, MAX_CLIENTS) == SOCKET_ERROR) {
        cerr << "Ошибка listen" << endl;
        closesocket(server_socket);
        WSACleanup();
        return 1;
    }
 
    cout << "Сервер запущен. Ожидание подключений...\n" << endl;
 
    // Основной цикл сервера
    while (true) {
        sockaddr_in client_addr;
        int client_addr_size = sizeof(client_addr);
 
        SOCKET client_socket = accept(server_socket, (sockaddr*)&client_addr, &client_addr_size);
        if (client_socket == INVALID_SOCKET) {
            cerr << "Ошибка accept" << endl;
            continue;
        }
 
        // Создание потока для клиента
        CreateThread(NULL, 0, ClientHandler, &client_socket, 0, NULL);
    }
 
    closesocket(server_socket);
    WSACleanup();
    return 0;
}
 
 
--
Сервер
