//1 задание 
//сервер бинарка
/*
#include <iostream>
#include <fstream>
#include <windows.h>
using namespace std;

struct Person
{
    char name[25]; // имя
    int height;    // рост
    int weight;    // вес
} B;

int answer;
long size_pred;

int main()
{
    ifstream fR;
    ofstream fA;
    setlocale(LC_ALL, "rus");

    // Абсолютные пути к файлам
    const char* nameR = "C:/Users/Ryzen/source/repos/REQUEST.bin";
    const char* nameA = "C:/Users/Ryzen/source/repos/ANSWER.bin";

    cout << "server is working" << endl;
    cout << "Files will be created in: C:/Users/Ryzen/source/repos/" << endl;

    // Создаем файлы, если они не существуют
    fA.open(nameA, ios::binary | ios::app);
    fA.close();

    // Начальные установки
    fR.open(nameR, ios::binary);
    if (!fR.is_open()) {
        // Если файла нет, создаем его
        fR.open(nameR, ios::binary | ios::app);
        fR.close();
        fR.open(nameR, ios::binary);
    }

    fR.seekg(0, ios::end);
    size_pred = fR.tellg(); // стартовая позиция сервера в файле REQUEST
    fR.close();

    // Начало работы сервера
    while (true)
    {
        fR.open(nameR, ios::binary); // открытие файла REQUEST
        fR.seekg(0, ios::end); // переход в конец файла REQUEST

        // Есть новые запросы от клиентов?
        while (size_pred >= fR.tellg())
        {
            Sleep(100);
            fR.seekg(0, ios::end);
        }

        // Получен новый запрос
        fR.seekg(size_pred, ios::beg); // переход к началу полученного запроса
        fR.read((char*)&B, sizeof(B)); // считывание данных клиента
        size_pred = fR.tellg(); // на конец обработанных данных
        fR.close();

        // Определение индекса массы тела
        double IMT = B.weight / (0.01 * B.height) / (0.01 * B.height);

        if (18.5 <= IMT && IMT < 25)
            answer = 1;
        else if (18.5 > IMT)
            answer = 0;
        else if (IMT >= 25)
            answer = 2;

        // Передача ответа клиенту
        fA.open(nameA, ios::binary | ios::app); // открытие файла ANSWER
        fA.write((char*)&answer, sizeof(answer)); // запись ответа клиенту
        fA.close();

        cout << "Processed request for: " << B.name << endl;
    }

    return 0;
}
*/
//сервер txt
//1 задание - сервер (текстовый файл)
#include <iostream>
#include <fstream>
#include <windows.h>
#include <string>
#include <sstream>
using namespace std;

struct Person
{
    string name;  // используем string вместо char[]
    int height;   // рост
    int weight;   // вес
} B;

int answer;
long size_pred;

int main()
{
    setlocale(LC_ALL, "rus");

    ifstream fR;
    ofstream fA;

    // Абсолютные пути к текстовым файлам
    const char* nameR = "C:/Users/Ryzen/source/repos/REQUEST.txt";
    const char* nameA = "C:/Users/Ryzen/source/repos/ANSWER.txt";

    cout << "server is working" << endl;
    cout << "Files will be created in: C:/Users/Ryzen/source/repos/" << endl;

    // Создаем файлы, если они не существуют
    fA.open(nameA, ios::app);
    fA.close();

    // Начальные установки
    fR.open(nameR);
    if (!fR.is_open()) {
        // Если файла нет, создаем его
        fR.open(nameR, ios::app);
        fR.close();
        fR.open(nameR);
    }

    fR.seekg(0, ios::end);
    size_pred = fR.tellg(); // стартовая позиция сервера в файле REQUEST
    fR.close();

    // Начало работы сервера
    while (true)
    {
        fR.open(nameR); // открытие текстового файла REQUEST
        fR.seekg(0, ios::end); // переход в конец файла REQUEST

        // Есть новые запросы от клиентов?
        while (size_pred >= fR.tellg())
        {
            Sleep(100);
            fR.seekg(0, ios::end);
        }

        // Получен новый запрос
        fR.seekg(size_pred, ios::beg); // переход к началу полученного запроса

        // Считывание данных клиента из текстового файла
        string line;
        if (getline(fR, line)) {
            stringstream ss(line);
            ss >> B.name >> B.height >> B.weight;
        }

        size_pred = fR.tellg(); // на конец обработанных данных
        fR.close();

        // Определение индекса массы тела
        double IMT = B.weight / (0.01 * B.height) / (0.01 * B.height);

        if (18.5 <= IMT && IMT < 25)
            answer = 1;
        else if (18.5 > IMT)
            answer = 0;
        else if (IMT >= 25)
            answer = 2;

        // Передача ответа клиенту
        fA.open(nameA, ios::app); // открытие текстового файла ANSWER
        fA << answer << endl; // запись ответа в текстовый файл
        fA.close();

        
    }

    return 0;
}
