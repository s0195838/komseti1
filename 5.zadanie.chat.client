#include <iostream>
#include <string>
#include <thread>
#include <atomic>
#include <winsock2.h>
#include <windows.h>
 
#pragma comment(lib, "ws2_32.lib")
#pragma warning(disable: 4996)
 
#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 12345
#define BUFFER_SIZE 2048
 
using namespace std;
 
atomic<bool> is_connected(true);
SOCKET client_socket;
 
// Типы сообщений
enum MessageType {
    MSG_LOGIN,
    MSG_LOGOUT,
    MSG_PUBLIC,
    MSG_PRIVATE,
    MSG_SYSTEM,
    MSG_USERLIST
};
 
struct ChatMessage {
    MessageType type;
    char from[32];
    char to[32];
    char message[BUFFER_SIZE];
};
 
// Функция для форматированного вывода
void PrintMessage(const ChatMessage& msg) {
    string sender = msg.from;
    string message = msg.message;
 
    if (msg.type == MSG_SYSTEM) {
        cout << "[СИСТЕМА] " << message << endl;
    }
    else if (msg.type == MSG_PRIVATE) {
        cout << "[ЛИЧНО от " << sender << "] " << message << endl;
    }
    else if (msg.type == MSG_PUBLIC) {
        if (sender != "SERVER") {
            cout << "[" << sender << "] " << message << endl;
        }
    }
}
 
// Поток для получения сообщений
DWORD WINAPI ReceiveThread(LPVOID) {
    while (is_connected) {
        ChatMessage msg;
        int bytes_received = recv(client_socket, (char*)&msg, sizeof(msg), 0);
 
        if (bytes_received <= 0) {
            if (is_connected) {
                cout << "\nСоединение с сервером разорвано" << endl;
                is_connected = false;
            }
            break;
        }
 
        PrintMessage(msg);
        cout << "> ";
        cout.flush();
    }
    return 0;
}
 
int main() {
     SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    setlocale(LC_ALL, "Russian");
   
 
    cout << "=== КЛИЕНТ ЧАТА ===\n";
    cout << "Команды:\n";
    cout << "  /users - список пользователей онлайн\n";
    cout << "  /private <ник> <сообщение> - личное сообщение\n";
    cout << "  /exit - выход из чата\n";
    cout << string(40, '-') << endl;
 
    // Инициализация Winsock
    WSADATA wsa_data;
    if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0) {
        cerr << "Ошибка инициализации Winsock" << endl;
        return 1;
    }
 
    // Создание сокета
    client_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (client_socket == INVALID_SOCKET) {
        cerr << "Ошибка создания сокета" << endl;
        WSACleanup();
        return 1;
    }
 
    // Подключение к серверу
    sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(SERVER_PORT);
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);
 
    cout << "Подключение к серверу " << SERVER_IP << ":" << SERVER_PORT << "...";
 
    if (connect(client_socket, (sockaddr*)&server_addr, sizeof(server_addr)) == SOCKET_ERROR) {
        cerr << "\nОшибка подключения к серверу" << endl;
        closesocket(client_socket);
        WSACleanup();
        return 1;
    }
 
    cout << " УСПЕШНО!\n" << endl;
 
    // Запуск потока для получения сообщений
    CreateThread(NULL, 0, ReceiveThread, NULL, 0, NULL);
 
    // Получение запроса на ввод ника
    ChatMessage welcome_msg;
    recv(client_socket, (char*)&welcome_msg, sizeof(welcome_msg), 0);
    PrintMessage(welcome_msg);
 
    // Ввод ника
    cout << "> ";
    string nickname;
    getline(cin, nickname);
 
    // Отправка ника серверу
    ChatMessage login_msg;
    login_msg.type = MSG_LOGIN;
    strcpy(login_msg.from, nickname.c_str());
    strcpy(login_msg.message, "");
    send(client_socket, (char*)&login_msg, sizeof(login_msg), 0);
 
    // Основной цикл ввода сообщений
    while (is_connected) {
        cout << "> ";
        string input;
        getline(cin, input);
 
        if (!is_connected) break;
 
        if (input.empty()) {
            continue;
        }
 
        ChatMessage msg;
        strcpy(msg.from, nickname.c_str());
        strcpy(msg.to, "");
 
        if (input == "/exit") {
            msg.type = MSG_PUBLIC;
            strcpy(msg.message, "/exit");
            send(client_socket, (char*)&msg, sizeof(msg), 0);
..             is_connected = false;
            break;
        }
        else {
            msg.type = MSG_PUBLIC;
            strcpy(msg.message, input.c_str());
            send(client_socket, (char*)&msg, sizeof(msg), 0);
        }
    }
 
    // Завершение работы
    closesocket(client_socket);
    WSACleanup();
 
    cout << "\nКлиент завершил работу." << endl;
    system("pause");
 
    return 0;
}
